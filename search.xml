<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vuex学习记录</title>
      <link href="/2020/05/09/vuex-ji-lu/"/>
      <url>/2020/05/09/vuex-ji-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="组件之间共享数据的方式"><a href="#组件之间共享数据的方式" class="headerlink" title="组件之间共享数据的方式"></a>组件之间共享数据的方式</h2><p>父向子传值：v-bind属性绑定<br>子向父传值：v-on事件绑定<br>兄弟组件之间共享数据：EvevuentBus</p><h5 id="Vuex是实现组件全局状态-数据-管理的一种机制，可以方便的实现组件之间数据的共享"><a href="#Vuex是实现组件全局状态-数据-管理的一种机制，可以方便的实现组件之间数据的共享" class="headerlink" title="Vuex是实现组件全局状态(数据)管理的一种机制，可以方便的实现组件之间数据的共享"></a>Vuex是实现组件全局状态(数据)管理的一种机制，可以方便的实现组件之间数据的共享</h5><p>1.安装vuex依赖包</p><pre><code>npm i vuex</code></pre><p>2.导入vuex包</p><pre><code>import Vuex from &#39;vuex&#39;Vue.use(Vuex)</code></pre><p>3.创建store对象</p><pre><code>//vuex核心属性const store = new Vuex.Store({  state: {  //state中就是存放全局共享的数据    count: 0  },  mutations: {},  actions: {},  modules: {}})</code></pre><p>成员列表：<br>state 存放状态<br>mutations state成员操作<br>getters 加工state成员给外界<br>actions 异步操作<br>modules 模块化状态管理</p><p>获取state中的数据<br>1.第一种方式</p><pre><code>this.$store.state.属性名</code></pre><p>2.第二种方式</p><pre><code>//从vuex中 按需导入mapState函数import { mapState } from &#39;vuex&#39;</code></pre><p>通过刚才导入的mapState函数，将当前组件需要的全局数据，映射为当前组件的computed计算属性</p><pre><code>computed:{    ...mapState([&#39;count&#39;])}</code></pre><h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p>1.只能通过mutation变更State数据，不可以直接操作State中的数据<br>2.通过这种方式虽然操作起来稍微繁琐一些，但是可以集中监控所有数据的变化<br>3.不要在mutation函数中执行异步操作（使用Actions）</p><pre><code>const store = new Vuex.Store({  state: {  //state中就是存放全局共享的数据    count: 0  },  mutations: {  //可以在触发mutation时传递参数    add(state,step){        //使count数据+1        state.count++        state.count += step    }  },  actions: {},  modules: {}})</code></pre><p>触发mutation</p><pre><code>import { mapState, mapMutations } from &#39;vuex&#39;methods:{    //第二种方式    ...mutations([&#39;sub&#39;])    handle1(){        //触发mutation的第一种方式        //触发mutation携带参数3        //commit的作用就是调用某一函数        this.$store.commit(&#39;add&#39;,3)        this.sub()        }}</code></pre><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>如果通过异步操作变更数据，必须通过Action,而不能使用Mutation,但是在Action中还是要触发Mutation的方式间接变更数据</p><p>在action中，不能直接修改state中的数据；必须通过context.commit()触发某个mutations才行</p><pre><code> //定义actions actions: {    addAsync(context) {      setTimeout(() =&gt; {        context.commit(&#39;add&#39;)      }, 1000)    },    subAsync(context) {      setTimeout(() =&gt; {        context.commit(&#39;sub&#39;)      }, 1000)    }  },</code></pre><pre><code>//调用Action btnHandler1() {     //触发action的第一种方式      this.$store.dispatch(&#39;subAsync&#39;)    }    //dispatch表示调用Action里面的函数    //！过程  加减组件页面调用Action里面的函数名称-》Action里面的异步函数调用mutations    //里面的函数，通过传过来的参数context.commit调用    //若想使用异步函数，必须在Action里面定义</code></pre><h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p>Getter用于对Store中数据进行加工处理形成新的数据。<br>1.Getter用于对Store中数据进行加工处理形成新的数据。类似Vue的计算属性<br>2.Store中数据发生变化，Getter的数据也发生变化<br>3.getter不会修改数据，只会对已有的数据进行包装</p><pre><code>//定义Getterconst store = new Vuex.Store({    state:{        count:0    },    getters:{        showNum:state =&gt;{            return &#39;当前最新的数量是【&#39;+state.count+&#39;】&#39;        }    }})</code></pre><p>如何使用getter</p><pre><code>//第一种方法{{$state.getters.showNum}}//第二种方法import {mapGetters} from &#39;vuex&#39;computed:{    ...mapGetters([&#39;showNum&#39;]})}{{showNum}}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nodejs跨域问题</title>
      <link href="/2020/05/06/nodejs-kua-yu-wen-ti/"/>
      <url>/2020/05/06/nodejs-kua-yu-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>跨域：<br>我们在开发中从一个服务器访问另一个服务器时，只要url中有以下其中一个不一样时就会发生跨域问题，这是浏览器的安全机制造成的，也被成为同源问题<br>    1.协议不同<br>      2.域名不同<br>      3.端口号不同<br>如何解决这种问题呢，以下我们在nodejs中利用CORS来处理跨域问题</p><p>但我们用ajax去请求数据发生跨域时，用nodejs在后台写一个服务器代理</p><p>首先是ajax请求时先去访问我们服务器代理，而不是访问你的最终的目标地址</p><pre><code>    $.post(&#39;服务器代理地址&#39;, {          url:            &#39;目标地址&#39;,        }).then(function(res) {          console.log(res);//返回的数据        });</code></pre><p>然后在服务器代理中利用CORS解决跨域问题</p><pre><code>//这个文件就是一个单独的专门用来做服务器代理解决跨域的，你只要运行这个文件将这个服务器打开就行了//若遇到跨域访问获取数据时先访问这个服务器地址就行const express = require(&quot;express&quot;);const cors = require(&quot;cors&quot;);const { get } = require(&quot;axios&quot;).default; //利用axois发送个网络请求const app = express();app.use(cors()); //就这一部就已经解决了跨域//如果访问的是本地服务器，现在这步就相当于已经解决了跨域问题//如果访问其他地址的服务器，那么此处就相当于一个服务器代理，解决跨域问题app.use(express.json());app.use(express.urlencoded());//服务器的代理请求地址app.post(&quot;/proxy&quot;, async(req, res) =&gt; {    const result = await get(req.body.url); //这里相当于发了一个网络请求，这不存在跨域，就像你在浏览器中直接输入请求的地址一样    res.json({        code: 1,        info: result.data,//axios请求的数据放在返回数据的data属性中    });});app.listen(3003, () =&gt; {    console.log(&quot;本地代理服务器运行在3003端口&quot;);});</code></pre><p>或者在nodejs中直接使用以下代码，解决跨域问题</p><pre><code>router.all(&#39;*&#39;,function(req,res,next){  res.header(&#39;Access-Control-Allow-Origin&#39;,&quot;*&quot;);  res.header(&#39;Access-Control-Allow-Methods&#39;,&quot;PUT,GET,POST,DELETE,OPTIONS&quot;);  res.header(&#39;Access-Control-Allow-Headers&#39;,&quot;X-Requested-With&quot;);  res.header(&#39;Access-Control-Allow-Headers&#39;,&quot;Content-Type&quot;);  res.header(&#39;Access-Control-Allow-Headers&#39;,&quot;mytoken&quot;);  next();})</code></pre>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/05/hello-world/"/>
      <url>/2020/05/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
