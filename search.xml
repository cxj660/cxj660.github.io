<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vuex学习记录</title>
      <link href="/2020/04/12/vuex-ji-lu/"/>
      <url>/2020/04/12/vuex-ji-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="组件之间共享数据的方式"><a href="#组件之间共享数据的方式" class="headerlink" title="组件之间共享数据的方式"></a>组件之间共享数据的方式</h2><p>父向子传值：v-bind属性绑定<br>子向父传值：v-on事件绑定<br>兄弟组件之间共享数据：EvevuentBus</p><h5 id="Vuex是实现组件全局状态-数据-管理的一种机制，可以方便的实现组件之间数据的共享"><a href="#Vuex是实现组件全局状态-数据-管理的一种机制，可以方便的实现组件之间数据的共享" class="headerlink" title="Vuex是实现组件全局状态(数据)管理的一种机制，可以方便的实现组件之间数据的共享"></a>Vuex是实现组件全局状态(数据)管理的一种机制，可以方便的实现组件之间数据的共享</h5><p>1.安装vuex依赖包</p><pre><code>npm i vuex</code></pre><p>2.导入vuex包</p><pre><code>import Vuex from &#39;vuex&#39;Vue.use(Vuex)</code></pre><p>3.创建store对象</p><pre><code>//vuex核心属性const store = new Vuex.Store({  state: {  //state中就是存放全局共享的数据    count: 0  },  mutations: {},  actions: {},  modules: {}})</code></pre><p>成员列表：<br>state 存放状态<br>mutations state成员操作<br>getters 加工state成员给外界<br>actions 异步操作<br>modules 模块化状态管理</p><p>获取state中的数据<br>1.第一种方式</p><pre><code>this.$store.state.属性名</code></pre><p>2.第二种方式</p><pre><code>//从vuex中 按需导入mapState函数import { mapState } from &#39;vuex&#39;</code></pre><p>通过刚才导入的mapState函数，将当前组件需要的全局数据，映射为当前组件的computed计算属性</p><pre><code>computed:{    ...mapState([&#39;count&#39;])}</code></pre><h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p>1.只能通过mutation变更State数据，不可以直接操作State中的数据<br>2.通过这种方式虽然操作起来稍微繁琐一些，但是可以集中监控所有数据的变化<br>3.不要在mutation函数中执行异步操作（使用Actions）</p><pre><code>const store = new Vuex.Store({  state: {  //state中就是存放全局共享的数据    count: 0  },  mutations: {  //可以在触发mutation时传递参数    add(state,step){        //使count数据+1        state.count++        state.count += step    }  },  actions: {},  modules: {}})</code></pre><p>触发mutation</p><pre><code>import { mapState, mapMutations } from &#39;vuex&#39;methods:{    //第二种方式    ...mutations([&#39;sub&#39;])    handle1(){        //触发mutation的第一种方式        //触发mutation携带参数3        //commit的作用就是调用某一函数        this.$store.commit(&#39;add&#39;,3)        this.sub()        }}</code></pre><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>如果通过异步操作变更数据，必须通过Action,而不能使用Mutation,但是在Action中还是要触发Mutation的方式间接变更数据</p><p>在action中，不能直接修改state中的数据；必须通过context.commit()触发某个mutations才行</p><pre><code> //定义actions actions: {    addAsync(context) {      setTimeout(() =&gt; {        context.commit(&#39;add&#39;)      }, 1000)    },    subAsync(context) {      setTimeout(() =&gt; {        context.commit(&#39;sub&#39;)      }, 1000)    }  },</code></pre><pre><code>//调用Action btnHandler1() {     //触发action的第一种方式      this.$store.dispatch(&#39;subAsync&#39;)    }    //dispatch表示调用Action里面的函数    //！过程  加减组件页面调用Action里面的函数名称-》Action里面的异步函数调用mutations    //里面的函数，通过传过来的参数context.commit调用    //若想使用异步函数，必须在Action里面定义</code></pre><h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p>Getter用于对Store中数据进行加工处理形成新的数据。<br>1.Getter用于对Store中数据进行加工处理形成新的数据。类似Vue的计算属性<br>2.Store中数据发生变化，Getter的数据也发生变化<br>3.getter不会修改数据，只会对已有的数据进行包装</p><pre><code>//定义Getterconst store = new Vuex.Store({    state:{        count:0    },    getters:{        showNum:state =&gt;{            return &#39;当前最新的数量是【&#39;+state.count+&#39;】&#39;        }    }})</code></pre><p>如何使用getter</p><pre><code>//第一种方法{{$state.getters.showNum}}//第二种方法import {mapGetters} from &#39;vuex&#39;computed:{    ...mapGetters([&#39;showNum&#39;]})}{{showNum}}</code></pre>]]></content>
      
      
      <categories>
          
          <category> VUE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/2020/01/12/markdown-de-ji-ben-yu-fa/"/>
      <url>/2020/01/12/markdown-de-ji-ben-yu-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h2><p><strong>优点：</strong></p><ol><li>因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。</li><li>操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可</li></ol><p><strong>缺点：</strong></p><ol><li>需要记一些语法（当然，是很简单。五分钟学会）。</li><li>有些平台不支持Markdown编辑模式。</li></ol><h3 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h3><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p><p>注：标准语法一般在#后跟个空格再写文字</p><p>示例：</p><pre><code># 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题</code></pre><hr><h3 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h3><p> <strong>加粗</strong><br>要加粗的文字左右分别用两个*号包起来</p><p><strong>斜体</strong><br>要倾斜的文字左右分别用一个*号包起来</p><p><strong>斜体加粗</strong><br>要倾斜和加粗的文字左右分别用三个*号包起来</p><p><strong>删除线</strong><br>要加删除线的文字左右分别用两个~~号包起来</p><p>示例：</p><pre><code>**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~</code></pre><p>效果如下：</p><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p><hr><h3 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h3><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br>n个…<br>貌似可以一直加下去，但没神马卵用</p><p>示例：</p><pre><code>&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</code></pre><p>效果如下：</p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h3 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h3><p>三个或者三个以上的 - 或者 * 都可以。</p><p>示例：</p><pre><code>-------********</code></pre><p>效果如下：<br>可以看到，显示效果是一样的。</p><hr><hr><hr><hr><h3 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h3><p>语法：</p><pre><code>![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</code></pre><p>示例：</p><pre><code>![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;)</code></pre><p>markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。</p><h3 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h3><p>语法：</p><pre><code>[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加</code></pre><p>示例：</p><pre><code>[github](https://github.com/)[百度](http://baidu.com)</code></pre><p>效果如下：</p><p><a href="https://github.com/" target="_blank" rel="noopener">github</a><br><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p><p><a href="超链接地址" target="_blank">超链接名</a></p><p>示例<br><a href="https://www.jianshu.com/u/1f5ac0cf6a8b" target="_blank">简书</a></p><h3 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h3><p><strong>无序列表</strong><br>语法：<br>无序列表用 - + * 任何一种都可以</p><pre><code>- 列表内容+ 列表内容* 列表内容</code></pre><p>注意：- + * 跟内容之间都要有一个空格</p><p>效果如下：</p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><p><strong>有序列表</strong><br>语法：<br>数字加点</p><pre><code>1. 列表内容2. 列表内容3. 列表内容注意：序号跟内容之间要有空格</code></pre><p>效果如下：</p><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><p><strong>列表嵌套</strong><br>上一级和下一级之间敲三个空格即可</p><ul><li><p>一级无序列表内容</p><ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li><p>一级无序列表内容</p><ol><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ol></li></ul><ol><li><p>一级有序列表内容</p><ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li><p>一级有序列表内容</p><ol><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ol></li></ol><h3 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h3><p>语法：</p><pre><code>表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略</code></pre><p>示例：</p><pre><code>姓名|技能|排行--|:--:|---:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟</code></pre><p>效果如下：</p><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><p>插入其他内容：<br>测试：内容两侧各一个下划线斜体，各两个下划线黑体（还是加粗）</p><table><thead><tr><th align="center">name</th><th align="center">age</th><th align="center">blog</th></tr></thead><tbody><tr><td align="center"><em>斜体</em></td><td align="center">12</td><td align="center">哇哈哈</td></tr><tr><td align="center"><strong>加粗</strong></td><td align="center">13</td><td align="center">小米</td></tr></tbody></table><h3 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h3><p>语法：<br>单行代码：代码之间分别用一个反引号包起来</p><pre><code>    `代码内容`</code></pre><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><pre><code>(```)  代码...  代码...  代码...(```)</code></pre><p><strong>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</strong></p><p>示例：</p><p>单行代码</p><pre><code>`create database hero;`</code></pre><p>代码块</p><pre><code>(```)    function fun(){         echo &quot;这是一句非常牛逼的代码&quot;;    }    fun();(```)</code></pre><p>效果如下：</p><p>单行代码</p><p>create database hero;</p><p>代码块</p><pre><code>function fun(){  echo &quot;这是一句非常牛逼的代码&quot;;}fun();</code></pre><h3 id="十、流程图"><a href="#十、流程图" class="headerlink" title="十、流程图"></a>十、流程图</h3><pre><code>```mermaidflowchatst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;```</code></pre><p>效果如下：<br>博客不支持流程图，所以截了个图<br><img src="https://img-blog.csdnimg.cn/2020051513010553.png" alt="流程图"></p>]]></content>
      
      
      <categories>
          
          <category> MD </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nodejs跨域问题</title>
      <link href="/2020/01/03/nodejs-kua-yu-wen-ti/"/>
      <url>/2020/01/03/nodejs-kua-yu-wen-ti/</url>
      
        <content type="html"><![CDATA[<p><strong>跨域：</strong><br>&ensp; 我们在开发中从一个服务器访问另一个服务器时，只要url中有以下其中一个不一样时就会发生跨域问题，这是浏览器的安全机制造成的，也被成为同源问题</p><ol><li>协议不同</li><li>域名不同</li><li>端口号不同</li></ol><p>如何解决这种问题呢，以下我们在nodejs中利用CORS来处理跨域问题</p><p>但我们用ajax去请求数据发生跨域时，用nodejs在后台写一个服务器代理</p><p>首先是ajax请求时先去访问我们服务器代理，而不是访问你的最终的目标地址</p><pre><code>    $.post(&#39;服务器代理地址&#39;, {          url:            &#39;目标地址&#39;,        }).then(function(res) {          console.log(res);//返回的数据        });</code></pre><p>然后在服务器代理中利用CORS解决跨域问题</p><pre><code>//这个文件就是一个单独的专门用来做服务器代理解决跨域的，你只要运行这个文件将这个服务器打开就行了//若遇到跨域访问获取数据时先访问这个服务器地址就行const express = require(&quot;express&quot;);const cors = require(&quot;cors&quot;);const { get } = require(&quot;axios&quot;).default; //利用axois发送个网络请求const app = express();app.use(cors()); //就这一部就已经解决了跨域//如果访问的是本地服务器，现在这步就相当于已经解决了跨域问题//如果访问其他地址的服务器，那么此处就相当于一个服务器代理，解决跨域问题app.use(express.json());app.use(express.urlencoded());//服务器的代理请求地址app.post(&quot;/proxy&quot;, async(req, res) =&gt; {    const result = await get(req.body.url); //这里相当于发了一个网络请求，这不存在跨域，就像你在浏览器中直接输入请求的地址一样    res.json({        code: 1,        info: result.data,//axios请求的数据放在返回数据的data属性中    });});app.listen(3003, () =&gt; {    console.log(&quot;本地代理服务器运行在3003端口&quot;);});</code></pre><p>或者在nodejs中直接使用以下代码，解决跨域问题</p><pre><code>router.all(&#39;*&#39;,function(req,res,next){  res.header(&#39;Access-Control-Allow-Origin&#39;,&quot;*&quot;);  res.header(&#39;Access-Control-Allow-Methods&#39;,&quot;PUT,GET,POST,DELETE,OPTIONS&quot;);  res.header(&#39;Access-Control-Allow-Headers&#39;,&quot;X-Requested-With&quot;);  res.header(&#39;Access-Control-Allow-Headers&#39;,&quot;Content-Type&quot;);  res.header(&#39;Access-Control-Allow-Headers&#39;,&quot;mytoken&quot;);  next();})</code></pre>]]></content>
      
      
      <categories>
          
          <category> NODE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Flex布局</title>
      <link href="/2019/10/12/flex-dan-xing-he-mo-xing/"/>
      <url>/2019/10/12/flex-dan-xing-he-mo-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Flex-布局是什么"><a href="#一、Flex-布局是什么" class="headerlink" title="一、Flex 布局是什么?"></a>一、Flex 布局是什么?</h3><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>任何一个容器都可以指定为 Flex 布局。</p><pre><code>.box{  display: flex;}</code></pre><p>行内元素也可以使用 Flex 布局。</p><pre><code>.box{  display: inline-flex;}</code></pre><p>Webkit 内核的浏览器，必须加上-webkit前缀。</p><pre><code>.box{  display: -webkit-flex; /* Safari */  display: flex;}</code></pre><p>注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。</p><h3 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h3><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><h3 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h3><p>以下6个属性设置在容器上。</p><ol><li>flex-direction            主轴方向</li><li>flex-wrap                换行</li><li>flex-flow                前两个的简写形式</li><li>justify-content            主轴对齐方式</li><li>align-items            交叉轴对其方式</li><li>align-content            </li></ol><p><strong>3.1 flex-direction属性</strong><br>  &#8195; flex-direction属性决定主轴的方向（即项目的排列方向）。</p><pre><code>.box {  flex-direction: row | row-reverse | column | column-reverse;}</code></pre><p>它可能有4个值。</p><ol><li>row（默认值）：主轴为水平方向，起点在左端。</li><li>row-reverse：主轴为水平方向，起点在右端。</li><li>column：主轴为垂直方向，起点在上沿。</li><li>column-reverse：主轴为垂直方向，起点在下沿。</li></ol><p><strong>3.2 flex-wrap属性</strong><br>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p><pre><code>.box{  flex-wrap: nowrap | wrap | wrap-reverse;}</code></pre><p>它可能取三个值。</p><ol><li>nowrap（默认）：不换行。</li><li>wrap：换行，第一行在上方。</li><li>wrap-reverse：换行，第一行在下方。</li></ol><p><strong>3.3 flex-flow</strong><br>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p><pre><code>.box {  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;}</code></pre><p><strong>3.4 justify-content属性</strong><br>justify-content属性定义了项目在主轴上的对齐方式。</p><pre><code>.box {  justify-content: flex-start | flex-end | center | space-between | space-around;}</code></pre><p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p><ol><li>flex-start（默认值）：左对齐</li><li>flex-end：右对齐</li><li>center： 居中</li><li>space-between：两端对齐，项目之间的间隔都相等。</li><li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ol><p><strong>3.5 align-items属性</strong><br>align-items属性定义项目在交叉轴上如何对齐。</p><pre><code>.box {  align-items: flex-start | flex-end | center | baseline | stretch;}</code></pre><p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p><ol><li>flex-start：交叉轴的起点对齐。</li><li>flex-end：交叉轴的终点对齐。</li><li>center：交叉轴的中点对齐。</li><li>baseline: 项目的第一行文字的基线对齐。</li><li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ol><p><strong>3.6 align-content属性</strong><br>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><pre><code>.box {  align-content: flex-start | flex-end | center | space-between | space-around | stretch;}</code></pre><p>该属性可能取6个值。</p><ol><li>flex-start：与交叉轴的起点对齐。</li><li>flex-end：与交叉轴的终点对齐。</li><li>center：与交叉轴的中点对齐。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li>stretch（默认值）：轴线占满整个交叉轴。</li></ol><h3 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h3><p>以下6个属性设置在项目上。</p><ol><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ol><p><strong>4.1 order属性</strong><br>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><pre><code>.item {  order: &lt;integer&gt;;}</code></pre><p><strong>4.2 flex-grow属性</strong><br>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><pre><code>.item {  flex-grow: &lt;number&gt;; /* default 0 */}</code></pre><p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><p><strong>4.3 flex-shrink属性</strong><br>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><pre><code>.item {  flex-shrink: &lt;number&gt;; /* default 1 */}</code></pre><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br>负值对该属性无效。</p><p><strong>4.4 flex-basis属性</strong><br>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><pre><code>.item {  flex-basis: &lt;length&gt; | auto; /* default auto */}</code></pre><p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p><p><strong>4.5 flex属性</strong><br>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p><pre><code>.item {  flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]}</code></pre><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><p><strong>4.6 align-self属性</strong><br>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><pre><code>.item {  align-self: auto | flex-start | flex-end | center | baseline | stretch;}</code></pre><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。<br>（完）</p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
